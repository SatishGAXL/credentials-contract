#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0

	// contracts\CredentialsCombined.algo.ts:30
	// this.index.value = 0
	byte 0x696e646578 // "index"
	int 0
	app_global_put
	retsub

// uploadCertificate(string,string,string,string,string,string,string,string,string,bool,uint64,bool)uint64
*abi_route_uploadCertificate:
	// The ABI return prefix
	byte 0x151f7c75

	// isGDPRcompliant: bool
	txna ApplicationArgs 12
	dup
	len
	int 1
	==

	// argument 0 (isGDPRcompliant) for uploadCertificate must be a bool
	assert
	int 0
	getbit

	// assetId: uint64
	txna ApplicationArgs 11
	btoi

	// hasClawback: bool
	txna ApplicationArgs 10
	dup
	len
	int 1
	==

	// argument 2 (hasClawback) for uploadCertificate must be a bool
	assert
	int 0
	getbit

	// courseEndDate: string
	txna ApplicationArgs 9
	extract 2 0

	// courseStartDate: string
	txna ApplicationArgs 8
	extract 2 0

	// courseTitle: string
	txna ApplicationArgs 7
	extract 2 0

	// eventName: string
	txna ApplicationArgs 6
	extract 2 0

	// instituteName: string
	txna ApplicationArgs 5
	extract 2 0

	// studentName: string
	txna ApplicationArgs 4
	extract 2 0

	// studentEmail: string
	txna ApplicationArgs 3
	extract 2 0

	// ipfs_hash: string
	txna ApplicationArgs 2
	extract 2 0

	// url: string
	txna ApplicationArgs 1
	extract 2 0

	// execute uploadCertificate(string,string,string,string,string,string,string,string,string,bool,uint64,bool)uint64
	callsub uploadCertificate
	itob
	concat
	log
	int 1
	return

// uploadCertificate(url: string, ipfs_hash: string, studentEmail: string, studentName: string, instituteName: string, eventName: string, courseTitle: string, courseStartDate: string, courseEndDate: string, hasClawback: boolean, assetId: uint64, isGDPRcompliant: boolean): uint64
uploadCertificate:
	proto 12 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\CredentialsCombined.algo.ts:47
	// issuedAddress = this.txn.sender
	txn Sender
	frame_bury 0 // issuedAddress: address

	// contracts\CredentialsCombined.algo.ts:48
	// nftIndex = assetId === 0 ? 0 : assetId
	frame_dig -11 // assetId: uint64
	int 0
	==
	bz *ternary0_false
	int 0
	b *ternary0_end

*ternary0_false:
	frame_dig -11 // assetId: uint64

*ternary0_end:
	frame_bury 1 // nftIndex: uint64

	// contracts\CredentialsCombined.algo.ts:49
	// certificate: CertificateMetadata = {
	//       url: url,
	//       ipfs_hash: ipfs_hash,
	//       studentEmail: studentEmail,
	//       studentName: studentName,
	//       instituteName: instituteName,
	//       eventName: eventName,
	//       issuedAddress: issuedAddress,
	//       owner: issuedAddress,
	//       courseTitle: courseTitle,
	//       courseStartDate: courseStartDate,
	//       courseEndDate: courseEndDate,
	//       hasClawback: hasClawback,
	//       assetId: nftIndex,
	//       isGDPRcompliant: isGDPRcompliant,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x005a // initial head offset
	frame_dig 0 // issuedAddress: address
	callsub *process_static_tuple_element
	frame_dig 0 // issuedAddress: address
	callsub *process_static_tuple_element
	frame_dig 1 // nftIndex: uint64
	itob
	callsub *process_static_tuple_element
	byte 0x00
	int 0
	frame_dig -10 // hasClawback: boolean
	setbit
	int 1
	frame_dig -12 // isGDPRcompliant: boolean
	setbit
	callsub *process_static_tuple_element
	frame_dig -1 // url: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // ipfs_hash: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // studentEmail: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -4 // studentName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -5 // instituteName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -6 // eventName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -7 // courseTitle: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -8 // courseStartDate: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -9 // courseEndDate: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // certificate: CertificateMetadata

	// contracts\CredentialsCombined.algo.ts:65
	// this.certificates(this.index.value).value = certificate
	byte 0x696e646578 // "index"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig 2 // certificate: CertificateMetadata
	box_put

	// contracts\CredentialsCombined.algo.ts:66
	// this.index.value = this.index.value + 1
	byte 0x696e646578 // "index"
	dup
	app_global_get
	int 1
	+
	app_global_put

	// contracts\CredentialsCombined.algo.ts:67
	// this.NewCertificate.log({ index: this.index.value - 1, certificate: certificate })
	byte 0x05a96e82 // NewCertificate(uint64,(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	byte 0x696e646578 // "index"
	app_global_get
	int 1
	-
	itob
	callsub *process_static_tuple_element
	frame_dig 2 // certificate: CertificateMetadata
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts\CredentialsCombined.algo.ts:68
	// return this.index.value - 1;
	byte 0x696e646578 // "index"
	app_global_get
	int 1
	-

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getCertificate(uint64)(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string)
*abi_route_getCertificate:
	// The ABI return prefix
	byte 0x151f7c75

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute getCertificate(uint64)(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string)
	callsub getCertificate
	concat
	log
	int 1
	return

// getCertificate(index: uint64): CertificateMetadata
getCertificate:
	proto 1 1

	// contracts\CredentialsCombined.algo.ts:72
	// assert(this.certificates(index).exists, 'Invalid Index')
	frame_dig -1 // index: uint64
	itob
	box_len
	swap
	pop

	// Invalid Index
	assert

	// contracts\CredentialsCombined.algo.ts:73
	// return this.certificates(index).value;
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	retsub

// changeOwner(uint64,address)void
*abi_route_changeOwner:
	// newOwner: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (newOwner) for changeOwner must be a address
	assert

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeOwner(uint64,address)void
	callsub changeOwner
	int 1
	return

// changeOwner(index: uint64, newOwner: Address): void
changeOwner:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts\CredentialsCombined.algo.ts:77
	// assert(this.certificates(index).exists, 'Invalid Index')
	frame_dig -1 // index: uint64
	itob
	box_len
	swap
	pop

	// Invalid Index
	assert

	// contracts\CredentialsCombined.algo.ts:78
	// issuedAddress = this.certificates(index).value.issuedAddress
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_bury 0 // issuedAddress: address

	// contracts\CredentialsCombined.algo.ts:79
	// assert(issuedAddress == this.txn.sender, 'Only issuedAddress Can Update this field')
	frame_dig 0 // issuedAddress: address
	txn Sender
	==

	// Only issuedAddress Can Update this field
	assert

	// contracts\CredentialsCombined.algo.ts:80
	// this.certificates(index).replace(32, rawBytes(newOwner))
	frame_dig -1 // index: uint64
	itob
	int 32
	frame_dig -2 // newOwner: Address
	box_replace

	// contracts\CredentialsCombined.algo.ts:81
	// this.ChangedCertificate.log({ index: index, certificate: this.certificates(index).value })
	byte 0xc87748e9 // ChangedCertificate(uint64,(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	frame_dig -1 // index: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

// changeMetadata(uint64,bool,string,string,string,string,string,string,string,string,string,bool)void
*abi_route_changeMetadata:
	// isGDPRcompliant: bool
	txna ApplicationArgs 12
	dup
	len
	int 1
	==

	// argument 0 (isGDPRcompliant) for changeMetadata must be a bool
	assert
	int 0
	getbit

	// courseEndDate: string
	txna ApplicationArgs 11
	extract 2 0

	// courseStartDate: string
	txna ApplicationArgs 10
	extract 2 0

	// courseTitle: string
	txna ApplicationArgs 9
	extract 2 0

	// eventName: string
	txna ApplicationArgs 8
	extract 2 0

	// instituteName: string
	txna ApplicationArgs 7
	extract 2 0

	// studentName: string
	txna ApplicationArgs 6
	extract 2 0

	// studentEmail: string
	txna ApplicationArgs 5
	extract 2 0

	// ipfs_hash: string
	txna ApplicationArgs 4
	extract 2 0

	// url: string
	txna ApplicationArgs 3
	extract 2 0

	// hasClawback: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==

	// argument 10 (hasClawback) for changeMetadata must be a bool
	assert
	int 0
	getbit

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeMetadata(uint64,bool,string,string,string,string,string,string,string,string,string,bool)void
	callsub changeMetadata
	int 1
	return

// changeMetadata(index: uint64, hasClawback: boolean, url: string, ipfs_hash: string, studentEmail: string, studentName: string, instituteName: string, eventName: string, courseTitle: string, courseStartDate: string, courseEndDate: string, isGDPRcompliant: boolean): void
changeMetadata:
	proto 12 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\CredentialsCombined.algo.ts:98
	// assert(this.certificates(index).exists, 'Invalid Index')
	frame_dig -1 // index: uint64
	itob
	box_len
	swap
	pop

	// Invalid Index
	assert

	// contracts\CredentialsCombined.algo.ts:99
	// issuedAddress = this.certificates(index).value.issuedAddress
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_bury 0 // issuedAddress: address

	// contracts\CredentialsCombined.algo.ts:100
	// assert(issuedAddress == this.txn.sender, 'Only issuedAddress Can Update this field')
	frame_dig 0 // issuedAddress: address
	txn Sender
	==

	// Only issuedAddress Can Update this field
	assert

	// contracts\CredentialsCombined.algo.ts:101
	// oldMetadata = this.certificates(index).value
	frame_dig -1 // index: uint64
	itob
	frame_bury 1 // storage key//oldMetadata

	// contracts\CredentialsCombined.algo.ts:102
	// newMetadata: CertificateMetadata = {
	//       url: url,
	//       ipfs_hash: ipfs_hash,
	//       studentEmail: studentEmail,
	//       studentName: studentName,
	//       instituteName: instituteName,
	//       eventName: eventName,
	//       issuedAddress: oldMetadata.issuedAddress,
	//       owner: oldMetadata.owner,
	//       courseTitle: courseTitle,
	//       courseStartDate: courseStartDate,
	//       courseEndDate: courseEndDate,
	//       assetId: oldMetadata.assetId,
	//       hasClawback: hasClawback,
	//       isGDPRcompliant: isGDPRcompliant,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x005a // initial head offset
	frame_dig 1 // storage key//oldMetadata
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//oldMetadata
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 32 32
	callsub *process_static_tuple_element
	frame_dig 1 // storage key//oldMetadata
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	itob
	callsub *process_static_tuple_element
	byte 0x00
	int 0
	frame_dig -2 // hasClawback: boolean
	setbit
	int 1
	frame_dig -12 // isGDPRcompliant: boolean
	setbit
	callsub *process_static_tuple_element
	frame_dig -3 // url: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -4 // ipfs_hash: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -5 // studentEmail: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -6 // studentName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -7 // instituteName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -8 // eventName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -9 // courseTitle: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -10 // courseStartDate: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -11 // courseEndDate: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // newMetadata: CertificateMetadata

	// contracts\CredentialsCombined.algo.ts:118
	// this.certificates(index).value = newMetadata
	frame_dig -1 // index: uint64
	itob
	dup
	box_del
	pop
	frame_dig 2 // newMetadata: CertificateMetadata
	box_put

	// contracts\CredentialsCombined.algo.ts:119
	// this.ChangedCertificate.log({ index: index, certificate: this.certificates(index).value })
	byte 0xc87748e9 // ChangedCertificate(uint64,(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	frame_dig -1 // index: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

// claimCertificate(uint64,pay)void
*abi_route_claimCertificate:
	// verifyTxn: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 0 (verifyTxn) for claimCertificate must be a pay transaction
	assert

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimCertificate(uint64,pay)void
	callsub claimCertificate
	int 1
	return

// claimCertificate(index: uint64, verifyTxn: PayTxn): void
claimCertificate:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\CredentialsCombined.algo.ts:123
	// certificate = this.certificates(index).value
	frame_dig -1 // index: uint64
	itob
	frame_bury 0 // storage key//certificate

	// *if0_condition
	// contracts\CredentialsCombined.algo.ts:124
	// certificate.hasClawback
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	int 576
	getbit
	bz *if0_else

	// *if0_consequent
	// contracts\CredentialsCombined.algo.ts:125
	// assetId = certificate.assetId
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_bury 1 // assetId: uint64

	// contracts\CredentialsCombined.algo.ts:126
	// assert(assetId != 0, 'No NFT Minted for this Certificate')
	frame_dig 1 // assetId: uint64
	int 0
	!=

	// No NFT Minted for this Certificate
	assert

	// contracts\CredentialsCombined.algo.ts:127
	// asset = AssetID.fromUint64(certificate.assetId)
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_bury 2 // asset: uint64

	// contracts\CredentialsCombined.algo.ts:128
	// verifyPayTxn(verifyTxn, {
	//         sender: asset.freeze,
	//         receiver: asset.freeze,
	//         amount: 0,
	//       })
	// verify sender
	frame_dig -2 // verifyTxn: PayTxn
	gtxns Sender
	frame_dig 2 // asset: uint64
	asset_params_get AssetFreeze
	pop
	==

	// transaction verification failed: {"txn":"verifyTxn","field":"sender","expected":"asset.freeze"}
	assert

	// verify receiver
	frame_dig -2 // verifyTxn: PayTxn
	gtxns Receiver
	frame_dig 2 // asset: uint64
	asset_params_get AssetFreeze
	pop
	==

	// transaction verification failed: {"txn":"verifyTxn","field":"receiver","expected":"asset.freeze"}
	assert

	// verify amount
	frame_dig -2 // verifyTxn: PayTxn
	gtxns Amount
	int 0
	==

	// transaction verification failed: {"txn":"verifyTxn","field":"amount","expected":"0"}
	assert

	// contracts\CredentialsCombined.algo.ts:133
	// assert(asset.clawback == this.app.address, 'Clawback Not Set to Contract')
	frame_dig 2 // asset: uint64
	asset_params_get AssetClawback
	pop
	global CurrentApplicationAddress
	==

	// Clawback Not Set to Contract
	assert

	// contracts\CredentialsCombined.algo.ts:134
	// assert(asset.manager.assetBalance(assetId) > 0, 'Already Claimed')
	frame_dig 2 // asset: uint64
	asset_params_get AssetManager
	pop
	frame_dig 1 // assetId: uint64
	asset_holding_get AssetBalance
	pop
	int 0
	>

	// Already Claimed
	assert

	// contracts\CredentialsCombined.algo.ts:135
	// assert(this.txn.sender.isOptedInToAsset(assetId), 'Receiver Not Opted to Asset')
	txn Sender
	frame_dig 1 // assetId: uint64
	asset_holding_get AssetBalance
	swap
	pop

	// Receiver Not Opted to Asset
	assert

	// contracts\CredentialsCombined.algo.ts:136
	// sendAssetTransfer({
	//         xferAsset: asset,
	//         assetAmount: 1,
	//         assetSender: asset.manager,
	//         assetReceiver: this.txn.sender,
	//         fee: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\CredentialsCombined.algo.ts:137
	// xferAsset: asset
	frame_dig 2 // asset: uint64
	itxn_field XferAsset

	// contracts\CredentialsCombined.algo.ts:138
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// contracts\CredentialsCombined.algo.ts:139
	// assetSender: asset.manager
	frame_dig 2 // asset: uint64
	asset_params_get AssetManager
	pop
	itxn_field AssetSender

	// contracts\CredentialsCombined.algo.ts:140
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts\CredentialsCombined.algo.ts:141
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CredentialsCombined.algo.ts:143
	// this.certificates(index).replace(32, rawBytes(this.txn.sender))
	frame_dig -1 // index: uint64
	itob
	int 32
	txn Sender
	box_replace
	b *if0_end

*if0_else:
	// contracts\CredentialsCombined.algo.ts:145
	// this.certificates(index).replace(32, rawBytes(this.txn.sender))
	frame_dig -1 // index: uint64
	itob
	int 32
	txn Sender
	box_replace

*if0_end:
	// contracts\CredentialsCombined.algo.ts:147
	// this.CertificateClaimed.log({ index: index, certificate: this.certificates(index).value })
	byte 0xa68375fa // CertificateClaimed(uint64,(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	frame_dig -1 // index: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

// clawbackCertificate(uint64,address)void
*abi_route_clawbackCertificate:
	// holdingAddress: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (holdingAddress) for clawbackCertificate must be a address
	assert

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute clawbackCertificate(uint64,address)void
	callsub clawbackCertificate
	int 1
	return

// clawbackCertificate(index: uint64, holdingAddress: Address): void
clawbackCertificate:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts\CredentialsCombined.algo.ts:151
	// certificate = this.certificates(index).value
	frame_dig -1 // index: uint64
	itob
	frame_bury 0 // storage key//certificate

	// contracts\CredentialsCombined.algo.ts:152
	// assetId = certificate.assetId
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_bury 1 // assetId: uint64

	// *if1_condition
	// contracts\CredentialsCombined.algo.ts:153
	// certificate.hasClawback
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	int 576
	getbit
	bz *if1_else

	// *if1_consequent
	// contracts\CredentialsCombined.algo.ts:154
	// assert(assetId != 0, 'No NFT Minted for this Certificate')
	frame_dig 1 // assetId: uint64
	int 0
	!=

	// No NFT Minted for this Certificate
	assert

	// contracts\CredentialsCombined.algo.ts:155
	// asset = AssetID.fromUint64(certificate.assetId)
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_bury 2 // asset: uint64

	// contracts\CredentialsCombined.algo.ts:156
	// assert(asset.clawback == this.app.address, 'Clawback Not Set to Contract')
	frame_dig 2 // asset: uint64
	asset_params_get AssetClawback
	pop
	global CurrentApplicationAddress
	==

	// Clawback Not Set to Contract
	assert

	// contracts\CredentialsCombined.algo.ts:157
	// assert(asset.manager == this.txn.sender, 'Only Owner can Clawback')
	frame_dig 2 // asset: uint64
	asset_params_get AssetManager
	pop
	txn Sender
	==

	// Only Owner can Clawback
	assert

	// contracts\CredentialsCombined.algo.ts:158
	// assert(holdingAddress.assetBalance(assetId) > 0, 'Holding Address does not hold certificate')
	frame_dig -2 // holdingAddress: Address
	frame_dig 1 // assetId: uint64
	asset_holding_get AssetBalance
	pop
	int 0
	>

	// Holding Address does not hold certificate
	assert

	// contracts\CredentialsCombined.algo.ts:159
	// assert(this.txn.sender.isOptedInToAsset(assetId), 'Receiver Not Opted to Asset')
	txn Sender
	frame_dig 1 // assetId: uint64
	asset_holding_get AssetBalance
	swap
	pop

	// Receiver Not Opted to Asset
	assert

	// contracts\CredentialsCombined.algo.ts:160
	// sendAssetTransfer({
	//         xferAsset: asset,
	//         assetSender: holdingAddress,
	//         assetAmount: 1,
	//         assetReceiver: this.txn.sender,
	//         fee: 0,
	//       })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts\CredentialsCombined.algo.ts:161
	// xferAsset: asset
	frame_dig 2 // asset: uint64
	itxn_field XferAsset

	// contracts\CredentialsCombined.algo.ts:162
	// assetSender: holdingAddress
	frame_dig -2 // holdingAddress: Address
	itxn_field AssetSender

	// contracts\CredentialsCombined.algo.ts:163
	// assetAmount: 1
	int 1
	itxn_field AssetAmount

	// contracts\CredentialsCombined.algo.ts:164
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts\CredentialsCombined.algo.ts:165
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts\CredentialsCombined.algo.ts:167
	// this.certificates(index).replace(32, rawBytes(this.txn.sender))
	frame_dig -1 // index: uint64
	itob
	int 32
	txn Sender
	box_replace
	b *if1_end

*if1_else:
	// contracts\CredentialsCombined.algo.ts:169
	// assert(certificate.owner == this.txn.sender, 'Only Owner Can Clawback')
	frame_dig 0 // storage key//certificate
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	store 255 // full array
	load 255 // full array
	extract 32 32
	txn Sender
	==

	// Only Owner Can Clawback
	assert

	// contracts\CredentialsCombined.algo.ts:170
	// this.certificates(index).replace(32, rawBytes(this.txn.sender))
	frame_dig -1 // index: uint64
	itob
	int 32
	txn Sender
	box_replace

*if1_end:
	// contracts\CredentialsCombined.algo.ts:172
	// this.CertificateClawbacked.log({ index: index, certificate: this.certificates(index).value })
	byte 0xb552755d // CertificateClawbacked(uint64,(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000a // initial head offset
	frame_dig -1 // index: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // index: uint64
	itob
	box_get

	// box value does not exist: this.certificates(index).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "uploadCertificate(string,string,string,string,string,string,string,string,string,bool,uint64,bool)uint64"
	method "getCertificate(uint64)(address,address,uint64,bool,bool,string,string,string,string,string,string,string,string,string)"
	method "changeOwner(uint64,address)void"
	method "changeMetadata(uint64,bool,string,string,string,string,string,string,string,string,string,bool)void"
	method "claimCertificate(uint64,pay)void"
	method "clawbackCertificate(uint64,address)void"
	txna ApplicationArgs 0
	match *abi_route_uploadCertificate *abi_route_getCertificate *abi_route_changeOwner *abi_route_changeMetadata *abi_route_claimCertificate *abi_route_clawbackCertificate

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub